interface Transport {
    inner: WebTransport;
    datagramListener: (datagram: Uint8Array) => void;
}

const transport: Transport = {
    inner: null,
    datagramListener: null,
};

async function connect() {
    try {
        let protocol = window.location.protocol;
        let hostname = window.location.hostname;
        let port =
            window.location.port === "" ? "" : `:${window.location.port}`;
        let path = window.location.pathname;
        if (window.location.protocol === "file:") {
            protocol = "http:";
            hostname = "localhost";
            port = ":3000";
            path = "/";
        } else if (!path.endsWith("/")) {
            path = `${path}/`;
        }
        const response = await fetch(
            `${protocol}//${hostname}${port}${path}transport-certificate`,
            {
                mode: "cors",
            },
        );
        if (!response.ok) {
            throw new Error(`Response status: ${response.status}`);
        }
        const endpoint = await response.json();
        transport.inner = new WebTransport(
            `https://${hostname}:${endpoint.port}${path}`,
            {
                allowPooling: false,
                serverCertificateHashes: [
                    {
                        algorithm: "sha-256",
                        value: new Uint8Array(
                            endpoint.hash
                                .split(":")
                                .map(value => parseInt(value, 16)),
                        ),
                    },
                ],
            },
        );
        await transport.inner.ready;
        console.log("transport ready"); // @DEV
        transport.inner.closed.then(closeInfo => {
            console.log("transport closed", closeInfo.reason); // @DEV
            transport.inner = null;
            //(connect, 1000);
        });

        let buffer = new ArrayBuffer(1 << 24);
        let start = null;
        let receivedPackets = 0;
        const unidirectionalStreams =
            transport.inner.incomingUnidirectionalStreams;
        const streamReader = unidirectionalStreams.getReader();
        console.log("will read");
        while (true) {
            const { done, value: stream } = await streamReader.read();
            if (done) {
                break;
            }
            const reader = stream.getReader({ mode: "byob" });
            let offset = 0;
            let size = -1;
            while (true) {
                const { value: view, done } = await reader.read(
                    new Uint8Array(
                        buffer,
                        offset,
                        (size === -1 ? buffer.byteLength : size) - offset,
                    ),
                );
                if (done) {
                    break;
                }
                buffer = view.buffer;
                offset += view.length;
                while (true) {
                    if (size === -1) {
                        if (offset < 4) {
                            break;
                        }
                        size = new DataView(buffer).getUint32(0, true);
                    }
                    if (offset < size) {
                        break;
                    }
                    const data = new Uint8Array(buffer, 0, size);
                    if (start == null) {
                        start = performance.now();
                    }
                    let end = performance.now();
                    ++receivedPackets;
                    const expectedReception = receivedPackets * (1e3 / 60.0);
                    const actualReception = end - start + 1e3 / 60.0;
                    console.log(
                        `${receivedPackets}, size = ${size} B, expected at ${expectedReception.toFixed(3)} ms, actual = ${actualReception.toFixed(3)} ms, delta = ${(actualReception - expectedReception).toFixed(3)} ms`,
                    );
                    if (offset === size) {
                        offset = 0;
                        size = -1;
                        break;
                    }
                    new Uint8Array(buffer, 0, offset).copyWithin(
                        0,
                        size,
                        offset,
                    );
                    offset -= size;
                    size = -1;
                }
            }

            /*

            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              // value is an instance of WebTransportBidirectionalStream
              await readData(value.readable);
              await writeData(value.writable);
            }

            const { value, done } = await reader.read(buffer);
            if (done) {
                break;
            }
            if (start == null) {
                start = performance.now();
            }
            let end = performance.now();
            let packetIndex = 0;
            for (let byte = 0; byte < 8; ++byte) {
                packetIndex |= buffer[byte] << (56 - 8 * byte);
            }
            ++receivedPackets;
            dataSize += buffer.length;
            if (buffer[8] == 1) {
                console.log(
                    `duration=${end - start} ms, received ${receivedPackets} packets (${dataSize / 1e6} MB, ${((dataSize / (end - start)) * 1000) / 1e6} MB/s)`,
                );
            }
            */
        }

        /*
        (async () => {
            if (transport.inner != null) {
                const reader = transport.inner.datagrams.readable.getReader();
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        break;
                    }
                    if (transport.datagramListener != null) {
                        transport.datagramListener(value);
                    }
                }
            }
        })();
        */
    } catch (error) {
        console.error(error);
        if (transport.inner != null) {
            transport.inner.close();
            transport.inner = null;
        }
        //setTimeout(connect, 1000);
    }
}

connect();

export function attachDatagramListener(
    listener: (datagram: Uint8Array) => void,
) {
    transport.datagramListener = listener;
}
